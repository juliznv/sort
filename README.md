# 比较排序算法
梳理了常见的比较排序算法,并使用python3进行实现


## 冒泡排序
+ 依次比较相邻的元素,如果顺序不符,则将其交换
+ 从起始到结尾比较每对相邻元素,每次循环末尾元素为最大/最小
+ 重复以上步骤直至每对相邻元素比较完毕

## 选择排序
+ 选择起始元素为基准,和后续元素逐个比较,若较小/较大则与基准元素交换,结束后起始元素为最小/最大值
+ 排除起始元素,重复以上过程直至末尾元素

## 插入排序
+ 取出起始元素,默认其为有序数组
+ 依次将后续元素与有序数组依次比较,插入有序数组合适位置
+ 重复第二步直至末尾元素

## 希尔排序
+ 选择一个增量序列t1,t2,…,tk,其中ti>tj,tk=1
+ 按增量序列个数k,对序列进行k趟排序
+ 每趟排序,根据对应的增量ti将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

## 归并排序
+ 把长度为n的输入序列分成两个长度为n/2的子序列
+ 对这两个子序列分别采用归并排序
+ 将两个排序好的子序列合并成一个最终的排序序列

## 快速排序
+ 从数列中挑出一个元素，称为 “基准”（pivot）
+ 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）
+ 在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
+ 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序

## 堆排序
+ 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
+ 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
+ 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。